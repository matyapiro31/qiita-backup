#Bashは空白に弱い
ちゃんとしたアプリケーションならほとんど問題にならないですが、問題があるコードでも一見正しく動いているように見えます。
空白の処理ができていないと正しいファイル名でもエラーが発生します。
エラー処理が面倒なので空白を別の文字に置き換えて、使用することにします。
この際、どの文字に変換するかは個人の問題になりますが、僕は[互換空白文字](https://ja.wikipedia.org/wiki/Unicode%E6%96%87%E5%AD%97%E3%81%AE%E3%83%9E%E3%83%83%E3%83%94%E3%83%B3%E3%82%B0#.E7.A9.BA.E7.99.BD)を使っています。これを使うと普通のスペースにしか見えないのに、スペースではないということが実現できます。

```bash
#Different character!
if [ " " -ne " " ];then
   echo "Different character!"
fi
```
これら自体は空白そのものなので、どのフォントでも表示されませんから、コピー&ペーストしない場合はsedなどでこれらに置換してしまって大丈夫です。
ただ、傍から見ると同じ空白を置換しているようにしか見えないので、そこは問題ですが。
コマンドで出力するときも直接標準出力に出すのではなく、sedで次のように処理します。

```bash
command|sed -e 's/ /\ /g'
```
まあ別に問題ないなら大丈夫ですが。
これらは文字マップの類で入力するか、バイナリをダンプしてテキストに落とし込んだ時とかにしか出てこないので問題はないでしょう。
これがどうして必要かというと、どうしても`A B C...`の区切り文字としての空白とファイル名の中にある空白`file\ name`を区別できない場合があるからです。
例えば、`'a' '/path/to/file name' 'b'`とforで表示させたいときには

```bash
fname="/path/to/file name"
echo "$fname"
#'/path/to/file name'
echo "a $fname b"
#'a /path/to/file name b'
echo a\ "$fname"\ b
#a /path/to/file name b
echo a\ \'"$fname"\'\ b
#a '/path/to/file name' b
#とはなるけどforに渡すとa,/path/to/file,name,bになる。
```
となってうまく行きません。少なくとも置換なしでこれが出来る方法は思いつかなかったです。
